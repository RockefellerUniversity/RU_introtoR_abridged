<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>introToR_Session2.knit</title>
    <meta charset="utf-8" />
    <meta name="author" content="Rockefeller University, Bioinformatics Resource Centre" />
    <script src="libs/header-attrs-2.16/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="metropolisCustom.css" type="text/css" />
    <link rel="stylesheet" href="metropolis-fontsCustom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Introduction to R, Session 2
<html>
<div style="float:left">

</div>
<hr color='#EB811B' size=1px width=796px>
</html>
]
.author[
### Rockefeller University, Bioinformatics Resource Centre
]
.date[
### <a href="http://rockefelleruniversity.github.io/Intro_To_R_1Day/" class="uri">http://rockefelleruniversity.github.io/Intro_To_R_1Day/</a>
]

---





## Overview

- [Conditions and Loops](https://rockefelleruniversity.github.io/Intro_To_R_1Day/presentations/singlepage/introToR_Session2.html#conditions_and_loops)



&lt;!-- --- --&gt;
&lt;!-- #  Recap --&gt;

&lt;!-- Session 1 covered introduction to R data types and import/export of data. --&gt;

&lt;!-- - [Background to R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/presentations/singlepage/introToR_Session1.html#background-to-r) --&gt;
&lt;!-- - [Data types in R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/presentations/singlepage/introToR_Session1.html#data_types_in_r) --&gt;
&lt;!-- - [Reading and writing in R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/presentations/singlepage/introToR_Session1.html#reading-and-writing-data-in-r) --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Recap --&gt;

&lt;!-- R stores data in five main data types. --&gt;

&lt;!-- - **Vector** - Ordered collection of single data type (numeric/character/logical). --&gt;
&lt;!-- - **Matrix** - Table (ordered 2D collection) of single data type (numeric/character/logical). --&gt;
&lt;!-- - **Factors** - Ordered collection of ordinal or nominal catagories. --&gt;
&lt;!-- - **Data frame** - Table (ordered 2D array) of multiple data types of same length. --&gt;
&lt;!-- - **List** - Ordered collection of multiple data types of differing length. --&gt;

&lt;!-- ```{r,echo=T,eval=T} --&gt;
&lt;!-- aVector &lt;- c(1,2,3,4,5,6,7,8,9,10) --&gt;
&lt;!-- aMatrix &lt;- matrix(aVector,ncol=2,nrow=5,byrow = TRUE) --&gt;
&lt;!-- aFactor &lt;- factor(c("R","Python","R","R","Python"),levels = c("R","Python")) --&gt;
&lt;!-- aDataFrame &lt;- data.frame(Number=c(1,2,3,4,5),Factor=aFactor) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Recap --&gt;

&lt;!-- We can access and change information in our data.types using **indexing** with **[]**  (or **[[]]** for lists). --&gt;

&lt;!-- ```{r,echo=T,eval=T} --&gt;
&lt;!-- aVector &lt;- c(1,2,3,4,5,6,7,8,9,10) --&gt;
&lt;!-- aVector[10] --&gt;
&lt;!-- aVector[10] &lt;- 0 --&gt;
&lt;!-- aVector --&gt;

&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Recap --&gt;
&lt;!-- For matricies and data frames we use two indexes, specifying columns and rows. **matrix[_rowIndex_,_columnIndex_]** --&gt;

&lt;!-- .pull-left[ --&gt;
&lt;!-- ```{r,echo=T,eval=T,tidy=FALSE} --&gt;
&lt;!-- aMatrix &lt;- matrix(aVector,ncol=2, --&gt;
&lt;!--                   nrow=5,byrow = TRUE) --&gt;
&lt;!-- aMatrix --&gt;
&lt;!-- aMatrix[1,] --&gt;
&lt;!-- aMatrix[,1] --&gt;
&lt;!-- ``` --&gt;
&lt;!--   ] --&gt;
&lt;!-- .pull-right[ --&gt;
&lt;!-- ```{r,echo=T,eval=T,tidy=FALSE} --&gt;
&lt;!-- aMatrix[1,1] &lt;- 0 --&gt;
&lt;!-- aMatrix[,2] &lt;- 100 --&gt;
&lt;!-- aMatrix --&gt;
&lt;!-- ``` --&gt;
&lt;!--   ] --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Recap --&gt;

&lt;!-- Remember a matrix can only contain one data type (numeric, character etc). For mixed data types we use data frames. --&gt;

&lt;!-- .pull-left[ --&gt;
&lt;!-- ```{r,echo=T,eval=T,tidy=FALSE} --&gt;
&lt;!-- aMatrix &lt;- matrix(aVector,ncol=2, --&gt;
&lt;!--                   nrow=5,byrow = TRUE) --&gt;
&lt;!-- aMatrix --&gt;

&lt;!-- ``` --&gt;
&lt;!--   ] --&gt;
&lt;!-- .pull-right[ --&gt;
&lt;!-- ```{r,echo=T,eval=T,tidy=FALSE} --&gt;
&lt;!-- aMatrix[1,2] &lt;- "Word" --&gt;
&lt;!-- aMatrix --&gt;
&lt;!-- ``` --&gt;
&lt;!--   ] --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Recap --&gt;

&lt;!-- We can use logical operations to evaluate information our data types. --&gt;

&lt;!-- ```{r,echo=T,eval=T} --&gt;
&lt;!-- aVector &lt;- c(1,2,3,4,5,6,7,8,9,10) --&gt;
&lt;!-- aVector &gt; 9 --&gt;
&lt;!-- aFactor &lt;- factor(c("R","Python","R","R","Python"),levels = c("R","Python")) --&gt;
&lt;!-- aDataFrame &lt;- data.frame(Number=c(1,2,3,4,5),Factor=aFactor) --&gt;
&lt;!-- aDataFrame --&gt;
&lt;!-- aDataFrame$Factor == "R" --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Recap --&gt;

&lt;!-- We can use logical operations with indexing to subset or alter information held in our data types. --&gt;


&lt;!-- ```{r,echo=T,eval=T} --&gt;
&lt;!-- aVector &lt;- c(1,2,3,4,5,6,7,8,9,10) --&gt;
&lt;!-- aVector &gt; 5 --&gt;
&lt;!-- aVector[aVector &gt; 5] &lt;- 10 --&gt;
&lt;!-- aVector --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Recap --&gt;

&lt;!-- When replacing factor columns in data frames we have to remember the **levels**. --&gt;

&lt;!-- ```{r,echo=T,eval=T,tidy=T} --&gt;

&lt;!-- aFactor &lt;- factor(c("R","Python","R","R","Python"), --&gt;
&lt;!--                   levels = c("R","Python")) --&gt;
&lt;!-- aDataFrame &lt;- data.frame(Number=c(1,2,3,4,5), --&gt;
&lt;!--                          Factor=aFactor) --&gt;
&lt;!-- aDataFrame[aDataFrame$Factor == "R",2] &lt;- "NotPython" --&gt;
&lt;!-- aDataFrame --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;
&lt;!-- ## Recap --&gt;

&lt;!-- We can update levels in a data frame column as we would a factor. Now we can replace our elements in data frame. --&gt;

&lt;!-- ```{r,echo=T,eval=T,tidy=FALSE} --&gt;

&lt;!-- aDataFrame &lt;- data.frame(Number=c(1,2,3,4,5), --&gt;
&lt;!--                          Factor=aFactor) --&gt;
&lt;!-- aDataFrame$Factor &lt;- factor(aDataFrame$Factor, --&gt;
&lt;!--                             levels = c("R","Python","NotPython")) --&gt;
&lt;!-- aDataFrame[aDataFrame$Factor == "R",2] &lt;- "NotPython" --&gt;
&lt;!-- aDataFrame --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- ## Recap --&gt;


&lt;!-- Data can be read into R as a table with the **read.table()** function and written to file with the **write.table()** function. --&gt;

&lt;!-- ```{r,echo=T,eval=T} --&gt;
&lt;!-- Table &lt;- read.table("data/readThisTable.csv",sep=",",header=T,row.names=1) --&gt;
&lt;!-- Table[1:3,] --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ```{r,echo=T,eval=F} --&gt;
&lt;!-- write.table(Table,file="data/writeThisTable.csv", sep=",", row.names =F,col.names=T) --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;
&lt;!-- ## Recap --&gt;


&lt;!-- If we want to know how a function works or get an example on its use we can use **?** infront function name. --&gt;

&lt;!-- **?_FunctionName_** --&gt;

&lt;!-- ```{r,echo=T,eval=F} --&gt;
&lt;!-- ?merge --&gt;
&lt;!-- ``` --&gt;

---
class: inverse, center, middle

# Ordering, selecting and merging

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Working with your data

Data analysis typically starts when you want to start performing operations on whatever input data you have. Commonly types are:

* Ordering
* Selecting
* Merging

# Lets get some input data


```r
my_df &lt;- read.table("data/categoriesAndExpression.txt",sep="\t",header=T)
head(my_df)
```

```
##   geneName ofInterest    pathway Expression
## 1    Gene1   Selected Glycolysis   20.09519
## 2    Gene2   Selected Glycolysis   23.00306
## 3    Gene3   Selected Glycolysis   20.99712
## 4    Gene4   Selected Glycolysis   43.01145
## 5    Gene5   Selected Glycolysis   22.00567
## 6    Gene6   Selected Glycolysis   20.99162
```

## Ordering

The order function can be used to reorder objects in R. The result of this function is the numerical order of the input, from smallest to largest.


```r
order(my_df[,4])
```

```
##   [1]  28  50  49  60  43  29  15   1  37  31  52  34   6   3   9  22  33   5
##  [19]  54  27   8  14  59  48  36  21  30   2  42  51  45  56  39  35  24  11
##  [37]   7  25  12  40  46  57  10  44  55  38  23  19  32   4  53  79  64  96
##  [55]  90  73  98  65  91  80  74  97  83  85  68  77  94  62  70  87  69  17
##  [73]  86  71  88  16  63  89  78  72  95  99  92  66  81  75  82  84  67  18
##  [91]  93 100  61  76  20  58  41  47  26  13
```

## Ordering

We can use the result of order to index our data frame. This will reorder the dataframe based on the order. In this case we are reordeing based on lowest expression.


```r
my_df_ordered &lt;- my_df[order(my_df[,4]),]

head(my_df_ordered)
```

```
##    geneName  ofInterest    pathway Expression
## 28   Gene28 NotSelected Glycolysis   19.94369
## 50   Gene50 NotSelected Glycolysis   19.95572
## 49   Gene49 NotSelected Glycolysis   19.95703
## 60   Gene60 NotSelected Glycolysis   19.97635
## 43   Gene43 NotSelected Glycolysis   19.98250
## 29   Gene29 NotSelected Glycolysis   20.02165
```

## Ordering

Often we want to order based on the highest value i.e. we want the highest expression genes at the top of our data frame. We can use the decreasing argument to control this.  of the time we actually 


```r
my_df_ordered &lt;- my_df[order(my_df[,4], decreasing = T),]

head(my_df_ordered)
```

```
##    geneName  ofInterest    pathway Expression
## 13   Gene13    Selected Glycolysis   74.08310
## 26   Gene26 NotSelected Glycolysis   73.98877
## 47   Gene47 NotSelected Glycolysis   73.96610
## 41   Gene41 NotSelected Glycolysis   73.96022
## 58   Gene58 NotSelected Glycolysis   73.94659
## 20   Gene20    Selected       TGFb   66.09706
```

## Subsetting

Anotehr opertaion we oftenwant to do is subset our dataset based on a specific condition i.e. I want to only look at Glycolysis genes, or I only want to gene above a certain expression threshold. To do this we need to use a logical operator test to see if this if something is TRUE.

Here we see which genes have an expression greater than 60.

```r
my_df_ordered$Expression &gt; 70
```

```
##   [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [97] FALSE FALSE FALSE FALSE
```

---
## Logical operators

Operators that we commonly use are:

- **==**  evaluates as equal.
- **&gt;** and **&lt;** evaluates as greater or less than respectively.
- **&gt;=** and **&lt;=** evaluates as greater than or equal or less than or equal respectively.


---
## Logical and indexing

The result of these expressions is a logical vector of TRUE/FALSE values. These vectors can be used to index, just like numerical vectors. TRUE values are returned.


```r
idx &lt;- my_df_ordered$Expression &gt; 70
my_df_ordered[idx,]
```

```
##    geneName  ofInterest    pathway Expression
## 13   Gene13    Selected Glycolysis   74.08310
## 26   Gene26 NotSelected Glycolysis   73.98877
## 47   Gene47 NotSelected Glycolysis   73.96610
## 41   Gene41 NotSelected Glycolysis   73.96022
## 58   Gene58 NotSelected Glycolysis   73.94659
```

---

## Combining logical vectors

Logical vectors can be used in combination in order to index vectors. To combine logical vectors we can use some common R operators.

- **&amp;** - Requires both logical operators to be TRUE
- **|** - Requires either logical operator to be TRUE.
- **!** - Reverses the logical operator, so TRUE is FALSE and FALSE is TRUE.


```r
my_df_ordered[my_df_ordered$Expression &gt; 60 &amp; my_df_ordered$pathway == "TGFb",]
```

```
##     geneName  ofInterest pathway Expression
## 20    Gene20    Selected    TGFb   66.09706
## 76    Gene76 NotSelected    TGFb   63.08147
## 61    Gene61 NotSelected    TGFb   63.04337
## 100  Gene100 NotSelected    TGFb   62.93485
## 93    Gene93 NotSelected    TGFb   62.93153
```


---
## The %in% operator

A common task in R is to subset one vector by the values in another vector.

The **%in%** operator in the context **A %in% B** creates a logical vector of whether values in **A** matches any values in of **B**.


```r
my_favorite_genes &lt;- c("Gene1","Gene10","Gene15")
logical_index &lt;- my_df$geneName %in% my_favorite_genes
logical_index
```

```
##   [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
##  [13] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [97] FALSE FALSE FALSE FALSE
```

---
## The %in% operator

This can be then used to subset the values within one character vector by a those in a second.

```r
my_df[logical_index,]
```

```
##    geneName ofInterest    pathway Expression
## 1     Gene1   Selected Glycolysis   20.09519
## 10   Gene10   Selected Glycolysis   34.91377
## 15   Gene15   Selected Glycolysis   20.06247
```




## Merging

A common operation is to join two data frames by a column of common values.


.pull-left[


```r
my_df2 &lt;- read.table("data/gene_lengths.txt",sep="\t",header=T)

nrow(my_df2)
```

```
## [1] 15
```

```r
head(my_df2)
```

```
##    Gene Length
## 1 Gene1   1788
## 2 Gene3    213
## 3 Gene5    529
## 4 Gene7    234
## 5 Gene8   1638
## 6 Gene9    917
```
  ]

.pull-right[

```r
nrow(my_df)
```

```
## [1] 100
```
  ]

---
## Merging data frames

To do this we can use the **merge()** function with the data frames as the first two arguments. We can then specify the columns to merge by with the **by** argument. To keep only data pertaining to values common to both data frames the **all** argument is set to FALSE.



```r
merge_df &lt;- merge(my_df, my_df2, by.x="geneName","Gene", all=FALSE)
merge_df
```

```
##    geneName ofInterest    pathway Expression Length
## 1     Gene1   Selected Glycolysis   20.09519   1788
## 2    Gene10   Selected Glycolysis   34.91377   1882
## 3    Gene12   Selected Glycolysis   27.01314    501
## 4    Gene13   Selected Glycolysis   74.08310   1045
## 5    Gene15   Selected Glycolysis   20.06247   1869
## 6    Gene16   Selected       TGFb   56.03506    851
## 7    Gene17   Selected       TGFb   54.00140   1807
## 8    Gene18   Selected       TGFb   59.04783    600
## 9    Gene19   Selected       TGFb   42.91023   1889
## 10   Gene20   Selected       TGFb   66.09706    992
## 11    Gene3   Selected Glycolysis   20.99712    213
## 12    Gene5   Selected Glycolysis   22.00567    529
## 13    Gene7   Selected Glycolysis   26.07826    234
## 14    Gene8   Selected Glycolysis   22.92961   1638
## 15    Gene9   Selected Glycolysis   21.02250    917
```

&lt;!-- --- --&gt;
&lt;!-- ## Combining logical vectors --&gt;

&lt;!-- Logical vectors can be used in combination in order to index vectors. To combine logical vectors we can use some common R operators. --&gt;

&lt;!-- - **&amp;** - Requires both logical operators to be TRUE --&gt;
&lt;!-- - **|** - Requires either logical operator to be TRUE. --&gt;
&lt;!-- - **!** - Reverses the logical operator, so TRUE is FALSE and FALSE is TRUE. --&gt;

&lt;!-- ```{r vectorLogicalCombine_introtoR} --&gt;
&lt;!-- x &lt;- 1:10 --&gt;
&lt;!-- !x &gt; 4 --&gt;
&lt;!-- x &gt; 4 &amp; x &lt; 7 --&gt;
&lt;!-- x &gt; 4 | x &lt; 7 --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;
&lt;!-- ## Combining logical vectors --&gt;

&lt;!-- Such combinations can allow for complex selection of a vector's values. --&gt;
&lt;!-- ```{r vectorLogicalCombineIndex_introtoR} --&gt;
&lt;!-- x &lt;- 1:10 --&gt;
&lt;!-- x --&gt;
&lt;!-- x[x &gt; 4 &amp; x &lt; 7] --&gt;
&lt;!-- x[x &gt; 4 &amp; !x &lt; 7] --&gt;
&lt;!-- ``` --&gt;





---
class: inverse, center, middle

# Conditions and Loops

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Conditions and Loops


We have looked at using logical vectors as a way to index other data types.

```r
x &lt;- 1:10
x[x &lt; 4]
```

```
## [1] 1 2 3
```

Logicals are also used in controlling how scripted procedures execute.


&lt;!-- --- --&gt;
&lt;!-- ## Conditions and Loops --&gt;

&lt;!-- * &lt;span style="color:red"&gt;Conditional branching (if,else)&lt;/span&gt; --&gt;
&lt;!-- * &lt;span style="color:green"&gt;Loops (for, while)&lt;/span&gt; --&gt;

&lt;!-- &lt;span style="color:green"&gt;While&lt;/span&gt; I'm analysing data, &lt;span style="color:red"&gt;if&lt;/span&gt; I need to execute complex statistical procedures on the data I will use R &lt;span style="color:red"&gt;else&lt;/span&gt; I will use a calculator. --&gt;

---
## Conditional branching


Conditional branching is the evaluation of a logical to determine whether a chunk of code is executed.

In R, we use the **if** statement with the logical to be evaluated in **()** and dependent code to be executed in **{}**.

&lt;!-- # ```{r,message=T} --&gt;
&lt;!-- # x &lt;- TRUE --&gt;
&lt;!-- # if(x){ --&gt;
&lt;!-- #   message("x is true") --&gt;
&lt;!-- # } --&gt;
&lt;!-- # x &lt;- FALSE --&gt;
&lt;!-- # if(x){ --&gt;
&lt;!-- #   message("x is true") --&gt;
&lt;!-- # } --&gt;
&lt;!-- #  --&gt;
&lt;!-- # ``` --&gt;
&lt;!-- #  --&gt;
&lt;!-- # --- --&gt;
&lt;!-- # ## Evaluating with if() --&gt;
&lt;!-- #  --&gt;
&lt;!-- # More often, we construct the logical value within **()** itself. This can be termed the **condition**.  --&gt;


```r
x &lt;- 10
y &lt;- 4
if(x &gt; y){
  message("The value of x is ",x," which is greater than ", y)
}
```

```
## The value of x is 10 which is greater than 4
```

The message is printed above because x is greater than y. 


```r
y &lt;- 20
if(x &gt; y){
  message("The value of x is ",x," which is greater than ", y)
}
```
x is now no longer greater than y, so no message is printed.

It would be better if all outcomes have a message. So we want a message telling us what was the result of the condition.

---
## else following an if

.pull-left[
If we want to perform an operation when the condition is false we can follow the if() statement with an else statement.


```r
x &lt;- 3
if(x &lt; 5){
  message(x, " is less than to 5")
   }else{
     message(x," is greater than or equal to 5")
}
```

```
## 3 is less than to 5
```
  ]
.pull-right[
With the addition of the else statement, when x is not less than 5 the code following the else statement is executed.


```r
x &lt;- 10
if(x &lt; 5){
  message(x, " is less than 5")
   }else{
     message(x," is greater than or equal to 5")
}
```

```
## 10 is greater than or equal to 5
```

  ]

---
## else if

We may wish to execute different procedures under multiple conditions. This can be controlled in R using the else if() following an initial if() statement.

```r
x &lt;- 5
if(x &gt; 5){
  message(x," is greater than 5")
  }else if(x == 5){
    message(x," is 5")
  }else{
    message(x, " is less than 5")
  }
```

```
## 5 is 5
```

---
## ifelse()

A useful function to evaluate conditional statements over vectors is the **ifelse()** function.


```r
x &lt;- 1:10
x
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

The ifelse() functions take the arguments of the condition to evaluate, the action if the condition is true and the action when condition is false.


```r
ifelse(x &lt;= 3,"lessOrEqual","more") 
```

```
##  [1] "lessOrEqual" "lessOrEqual" "lessOrEqual" "more"        "more"       
##  [6] "more"        "more"        "more"        "more"        "more"
```

---
## ifelse()

We can use multiple nested **ifelse** functions to be apply more complex logical to vectors.


```r
ifelse(x == 3,"same",
       ifelse(x &lt; 3,"less","more")
      ) 
```

```
##  [1] "less" "less" "same" "more" "more" "more" "more" "more" "more" "more"
```

---
## Loops

The two main generic methods of looping in R are **while** and **for**

- **while** - *while* loops repeat the execution of code while a condition evaluates as true.

- **for** - *for* loops repeat the execution of code for a range of specified values.

&lt;!-- --- --&gt;
&lt;!-- ## While loops --&gt;

&lt;!-- While loops are most useful if you know the condition will be satisified but are not sure when (i.e. Looking for a point when a number first occurs in a list). --&gt;
&lt;!-- ```{r, message=TRUE} --&gt;
&lt;!-- x &lt;- 1 --&gt;
&lt;!-- while(x &lt; 3){ --&gt;
&lt;!--   message("x is ",x," ") --&gt;
&lt;!--   x &lt;- x+1 --&gt;
&lt;!-- } --&gt;
&lt;!-- message("Finally x is not less than 3") --&gt;
&lt;!-- ``` --&gt;

---
## For loops

For loops allow the user to cycle through a range of values applying an operation for every value.

Here we cycle through a numeric vector and print out its value.

```r
x &lt;- 1:5
for(i in x){
  message(i," ", appendLF = F)
}
```

```
## 1 2 3 4 5
```

Similarly we can cycle through other vector types (or lists).

```r
x &lt;- toupper(letters[1:5])
for(i in x){
  message(i," ", appendLF = F)
}
```

```
## A B C D E
```

---
## Looping through indices

We may wish to keep track of the position in x we are evaluating to retrieve the same index in other variables. A common practice is to loop though all possible index positions of x using the expression **1:length(x)**.


```r
geneName &lt;- c("Ikzf1","Myc","Igll1")
expression &lt;- c(10.4,4.3,6.5)
1:length(geneName)
```

```
## [1] 1 2 3
```

```r
for(i in 1:length(geneName)){
  message(geneName[i]," has an RPKM of ",expression[i])
}
```

```
## Ikzf1 has an RPKM of 10.4
```

```
## Myc has an RPKM of 4.3
```

```
## Igll1 has an RPKM of 6.5
```

---
## Loops and conditionals

Loops can be combined with conditional statements to allow for complex control of their execution over R objects. 
.pull-left[

```r
x &lt;- 1:13

for(i in 1:13){
  if(i &gt; 10){
    message("Number ",i," is greater than 10")
  }else if(i == 10){
    message("Number ",i," is  10") 
  }else{
    message("Number ",i," is less than 10") 
  }
}
```

  ]
.pull-right[

```
## Number 1 is less than  10
```

```
## Number 2 is less than  10
```

```
## Number 3 is less than  10
```

```
## Number 4 is less than  10
```

```
## Number 5 is less than  10
```

```
## Number 6 is less than  10
```

```
## Number 7 is less than  10
```

```
## Number 8 is less than  10
```

```
## Number 9 is less than  10
```

```
## Number 10 is  10
```

```
## Number 11 is greater than 10
```

```
## Number 12 is greater than 10
```

```
## Number 13 is greater than 10
```
  ]

&lt;!-- --- --&gt;
&lt;!-- ## Breaking loops --&gt;

&lt;!-- We can use conditionals to exit a loop if a condition is satisfied, just like a while loop. --&gt;

&lt;!-- .pull-left[ --&gt;
&lt;!-- ```{r,message=T,eval=F} --&gt;
&lt;!-- x &lt;- 1:13 --&gt;

&lt;!-- for(i in 1:13){ --&gt;
&lt;!--   if(i &lt; 10){ --&gt;
&lt;!--     message("Number ",i," is less than 10") --&gt;
&lt;!--   }else if(i == 10){ --&gt;
&lt;!--     message("Number ",i," is  10") --&gt;
&lt;!--     break --&gt;
&lt;!--   }else{ --&gt;
&lt;!--     message("Number ",i," is greater than  10")  --&gt;
&lt;!--   } --&gt;
&lt;!-- } --&gt;
&lt;!-- ``` --&gt;
&lt;!--   ] --&gt;

&lt;!-- .pull-right[ --&gt;
&lt;!-- ```{r,message=T,eval=T,echo=F} --&gt;
&lt;!-- x &lt;- 1:13 --&gt;

&lt;!-- for(i in 1:13){ --&gt;
&lt;!--   if(i &lt; 10){ --&gt;
&lt;!--     message("Number ",i, --&gt;
&lt;!--             " is less than 10") --&gt;
&lt;!--   }else if(i == 10){ --&gt;
&lt;!--     message("Number ",i, --&gt;
&lt;!--             " is  10") --&gt;
&lt;!--     break --&gt;
&lt;!--   }else{ --&gt;
&lt;!--     message("Number ",i, --&gt;
&lt;!--             " is greater than  10")  --&gt;
&lt;!--   } --&gt;
&lt;!-- } --&gt;
&lt;!-- ``` --&gt;
&lt;!--   ] --&gt;

---
## Functions to loop over data types

There are functions which allow you to loop over a data type and apply a function to the subsection of that data.

- **apply** - Apply function to rows or columns of a matrix/data frame and return results as a vector,matrix or list.

- **lapply** - Apply function to every element of a vector or list and return results as a list.

- **sapply** - Apply function to every element of a vector or list and return results as a vector,matrix or list.

&lt;!-- --- --&gt;
&lt;!-- ## Looping - apply() --&gt;

&lt;!-- The **apply()** function applys a function to the rows or columns of a matrix. The arguments **FUN** specifies the function to apply and **MARGIN** whether to apply the functions by rows/columns or both. --&gt;

&lt;!-- ``` --&gt;
&lt;!-- apply(DATA,MARGIN,FUN,...) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- - **DATA** - A matrix (or something to be coerced into a matrix) --&gt;
&lt;!-- - **MARGIN** - 1 for rows, 2 for columns, c(1,2) for cells --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## apply() example --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- matExample &lt;- matrix(c(1:4),nrow=2,ncol=2,byrow=T) --&gt;
&lt;!-- matExample --&gt;
&lt;!-- ``` --&gt;
&lt;!-- Get the mean of rows --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- apply(matExample,1,mean) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- Get the mean of columns --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- apply(matExample,2,mean) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Additional arguments to apply --&gt;

&lt;!-- Additional arguments to be used by the function in the apply loop can be specified after the function argument.  --&gt;

&lt;!-- Arguments may be ordered as if passed to function directly. For **paste()** function however this isn't possible. --&gt;


&lt;!-- ```{r} --&gt;
&lt;!-- apply(matExample,1,paste,collapse=";") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## lapply() --&gt;

&lt;!-- .pull-left[ --&gt;
&lt;!-- Similar to apply, **lapply** applies a function to every element of a vector or list.  --&gt;

&lt;!-- **lapply** returns a list object containing the results of evaluating the function. --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- lapply(c(1,2),mean) --&gt;
&lt;!-- ``` --&gt;
&lt;!--   ] --&gt;
&lt;!-- .pull-right[ --&gt;
&lt;!-- As with apply() additional arguments can be supplied after the function name argument. --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- lapply(list(1,c(NA,1),2),mean, na.rm=T) --&gt;
&lt;!-- ``` --&gt;
&lt;!--   ] --&gt;

---
## sapply()


**sapply** (*smart apply*) acts as lapply but attempts to return the results as the most appropriate data type.

Here sapply returns a vector where lapply would return lists.

```r
exampleVector &lt;- c(1,2,3,4,5)
exampleList &lt;- list(1,2,3,4,5)
sapply(exampleVector, mean, na.rm=T)
```

```
## [1] 1 2 3 4 5
```

```r
sapply(exampleList, mean, na.rm=T)
```

```
## [1] 1 2 3 4 5
```

---
## sapply() example

.pull-left[
In this example lapply returns a list of vectors from the quantile function.


```r
exampleList &lt;- list(row1=1:5, 
                    row2=6:10, 
                    row3=11:15)
exampleList
```

```
## $row1
## [1] 1 2 3 4 5
## 
## $row2
## [1]  6  7  8  9 10
## 
## $row3
## [1] 11 12 13 14 15
```
  ]

.pull-right[

```r
lapply(exampleList, quantile)
```

```
## $row1
##   0%  25%  50%  75% 100% 
##    1    2    3    4    5 
## 
## $row2
##   0%  25%  50%  75% 100% 
##    6    7    8    9   10 
## 
## $row3
##   0%  25%  50%  75% 100% 
##   11   12   13   14   15
```
  ]

---
## sapply() example 2

Here is an example of sapply parsing a result from the quantile function in a *smart* way.

When a function always returns a vector of the same length, sapply will create a matrix with elements by column.


```r
sapply(exampleList, quantile)
```

```
##      row1 row2 row3
## 0%      1    6   11
## 25%     2    7   12
## 50%     3    8   13
## 75%     4    9   14
## 100%    5   10   15
```

---
## sapply() example 3


When sapply cannot parse the result to a vector or matrix, a list will be returned.


```r
exampleList &lt;- list(df=data.frame(sample=paste0("patient",1:2), data=c(1,12)),
                    vec=c(1,3,4,5))
sapply(exampleList, summary)
```

```
## $df
##     sample               data      
##  Length:2           Min.   : 1.00  
##  Class :character   1st Qu.: 3.75  
##  Mode  :character   Median : 6.50  
##                     Mean   : 6.50  
##                     3rd Qu.: 9.25  
##                     Max.   :12.00  
## 
## $vec
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    1.00    2.50    3.50    3.25    4.25    5.00
```

&lt;!-- --- --&gt;
&lt;!-- ## Time for an exercise! --&gt;


&lt;!-- Exercise on loops and conditional branching can be found [here](../..//exercises/exercises/conditionsAndLoops_exercise.html) --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Answers to exercise --&gt;


&lt;!-- Answers can be found here  [here](../..//exercises/answers/conditionsAndLoops_answers.html) --&gt;


&lt;!-- --- --&gt;

class: inverse, center, middle

# Plotting

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt;

---


## Base plotting

Base plotting function *plot* does a good job at estimating what kind of plot you might want. The output varies depending on what type of data type is your input. 


```r
plot(merge_df[,c(4,5)])
```

![](introToR_Session2_files/figure-html/unnamed-chunk-33-1.png)&lt;!-- --&gt;

## Base plotting

Many plots types like factors. This helps the plotting deal with dividing your data into categories.


```r
plot(merge_df[,3])
```


```
## Warning in xy.coords(x, y, xlabel, ylabel, log): NAs introduced by coercion
```

```
## Warning in min(x): no non-missing arguments to min; returning Inf
```

```
## Warning in max(x): no non-missing arguments to max; returning -Inf
```

![](introToR_Session2_files/figure-html/unnamed-chunk-35-1.png)&lt;!-- --&gt;

```
## Error in plot.window(...) : need finite 'ylim' values
```

```
## [1] 1
```



```r
merge_df[,3] &lt;- factor(merge_df[,3])
plot(merge_df[,3])
```

![](introToR_Session2_files/figure-html/unnamed-chunk-36-1.png)&lt;!-- --&gt;

## Base plotting

There are also some functions for making specific plots, like boxplot.


```r
boxplot(Expression ~ pathway, merge_df)
```

![](introToR_Session2_files/figure-html/unnamed-chunk-37-1.png)&lt;!-- --&gt;

## Beyond Base plots
For more advance plots we recommend you check out our ggplot2 training. [R graph gallery](https://r-graph-gallery.com/index.html) is also a really useful website that has example plots and the code used to generate them. 

.pull-left[

```r
library(ggplot2)

ggplot(merge_df, aes(x=pathway, y=Expression, fill=pathway))+
  geom_violin()+
  geom_jitter(width=0.1)+
  theme_linedraw()+
  ggtitle("Gene Expression in Glycolyis and TGFb pathways")
```
  ]
  
.pull-right[
![](introToR_Session2_files/figure-html/unnamed-chunk-39-1.png)&lt;!-- --&gt;
  ]




&lt;!-- ## Custom functions --&gt;
&lt;!-- You can create your own functions easily in R using the **&lt;-** assignment and **function** statement.   --&gt;
&lt;!-- We put all our input arguments in **()** and all code to be executed in **{}**.   --&gt;
&lt;!-- Anything to be received back from the function is indicated by the **return** statement.   --&gt;

&lt;!-- In this case we can recapitulate the square function.  --&gt;
&lt;!-- ```{r makingfunctions,eval=FALSE} --&gt;
&lt;!-- myFirstFunction  &lt;- function(MYARGUMENT){ --&gt;
&lt;!--   ................... --&gt;
&lt;!--   ..CODE_TO_EXECUTE.. --&gt;
&lt;!--   ................... --&gt;
&lt;!--   return(MYRESULT) --&gt;
&lt;!-- } --&gt;

&lt;!-- myFirstFunction(MYARGUMENT=MY_USER_SUPPLIED_ARGUMENT) --&gt;

&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Custom functions --&gt;

&lt;!-- First lets create a function that can sum two numbers. We can call the function **myFirstFunction** and set our arguments as **num1** and **num2**. --&gt;


&lt;!-- ```{r makingfunctionsb} --&gt;
&lt;!-- myFirstFunction  &lt;- function(num1,num2){ --&gt;
&lt;!--   sumNum &lt;- num1+num2 --&gt;
&lt;!--   return(sumNum) --&gt;
&lt;!-- } --&gt;

&lt;!-- myResult &lt;- myFirstFunction(num1=2,num2=3) --&gt;

&lt;!-- myResult --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Returning multiple values --&gt;

&lt;!-- We can only **return** 1 object at a time from function. Here we create the multiple of our numbers and try and return alongside our sum. --&gt;


&lt;!-- ```{r makingfunctionsc,error=TRUE} --&gt;
&lt;!-- myFirstFunction  &lt;- function(num1,num2){ --&gt;
&lt;!--   sumNum &lt;- num1+num2 --&gt;
&lt;!--   multipleNum &lt;- num1*num2 --&gt;
&lt;!--   return(sumNum,multipleNum) --&gt;
&lt;!-- } --&gt;

&lt;!-- myResult &lt;- myFirstFunction(num1=2,num2=3) --&gt;

&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Returning multiple values --&gt;

&lt;!-- A simple solution is to pass back an object that contains both results. Here we create a named vector to return our multiple and sum. --&gt;


&lt;!-- ```{r makingfunctionsd,error=FALSE} --&gt;
&lt;!-- myFirstFunction  &lt;- function(num1,num2){ --&gt;
&lt;!--   sumNum &lt;- num1+num2 --&gt;
&lt;!--   multipleNum &lt;- num1*num2 --&gt;
&lt;!--   VectorOfResults &lt;- c(sumNum,multipleNum) --&gt;
&lt;!--   names(VectorOfResults) &lt;- c("multiple","sum") --&gt;
&lt;!--   return(VectorOfResults) --&gt;
&lt;!-- } --&gt;

&lt;!-- myResult &lt;- myFirstFunction(num1=2,num2=3) --&gt;
&lt;!-- myResult --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Returning multiple values --&gt;

&lt;!-- Lists are very useful here as they can contain different object classes in their elements and so we can return mixed data types from our functions using this. Below we return a list with elements of the input arguments as a vector and the result as a data.frame. --&gt;


&lt;!-- ```{r makingfunctionse,error=FALSE} --&gt;
&lt;!-- myFirstFunction  &lt;- function(num1,num2){ --&gt;
&lt;!--   sumNum &lt;- num1+num2 --&gt;
&lt;!--   multipleNum &lt;- num1*num2 --&gt;
&lt;!--   InputNumbers &lt;- c(FirstNum=num1,SecondNum=num2) --&gt;
&lt;!--   DF &lt;- data.frame(Sum=sumNum,Multiple=multipleNum) --&gt;
&lt;!--   listToReturn &lt;- list(Input=InputNumbers,Result=DF) --&gt;
&lt;!--   return(listToReturn) --&gt;
&lt;!-- } --&gt;

&lt;!-- myResult &lt;- myFirstFunction(num1=2,num2=3) --&gt;
&lt;!-- myResult --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Evaluate until return --&gt;

&lt;!-- In a function containing a **return** statement, the code up until the return statement is evaluated and anything after the return statement is not evaluated. --&gt;


&lt;!-- ```{r makingfunctionsf,error=FALSE} --&gt;
&lt;!-- myFirstFunction  &lt;- function(num1,num2){ --&gt;
&lt;!--   sumNum &lt;- num1+num2 --&gt;
&lt;!--   multipleNum &lt;- num1*num2 --&gt;
&lt;!--   InputNumbers &lt;- c(FirstNum=num1,SecondNum=num2) --&gt;
&lt;!--   DF &lt;- data.frame(Sum=sumNum,Multiple=multipleNum) --&gt;
&lt;!--   listToReturn &lt;- list(Input=InputNumbers,Result=DF) --&gt;
&lt;!--   message("Before return") --&gt;
&lt;!--   return(listToReturn) --&gt;
&lt;!--   message("After return") --&gt;
&lt;!-- } --&gt;

&lt;!-- myResult &lt;- myFirstFunction(num1=2,num2=3) --&gt;
&lt;!-- myResult --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## No return statement --&gt;

&lt;!-- If a function does not contain a return statement, the result of the last line in function is returned. --&gt;


&lt;!-- ```{r makingfunctionsg,error=FALSE} --&gt;
&lt;!-- myFirstFunction  &lt;- function(num1,num2){ --&gt;
&lt;!--   sumNum &lt;- num1+num2 --&gt;
&lt;!--   multipleNum &lt;- num1*num2 --&gt;
&lt;!--   InputNumbers &lt;- c(FirstNum=num1,SecondNum=num2) --&gt;
&lt;!--   DF &lt;- data.frame(Sum=sumNum,Multiple=multipleNum) --&gt;
&lt;!--   listToReturn &lt;- list(Input=InputNumbers,Result=DF) --&gt;
&lt;!--   listToReturn --&gt;
&lt;!-- } --&gt;

&lt;!-- myResult &lt;- myFirstFunction(num1=2,num2=3) --&gt;
&lt;!-- myResult --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Variable scope in functions --&gt;

&lt;!-- Variables defined in the arguments or within the function exist only within the environment of the function. --&gt;

&lt;!-- ```{r makingfunctionsh,error=TRUE} --&gt;
&lt;!-- myFirstFunction  &lt;- function(num1,num2){ --&gt;
&lt;!--   sumNum &lt;- num1+num2 --&gt;
&lt;!--   return(sumNum) --&gt;
&lt;!-- } --&gt;
&lt;!-- myResult &lt;- myFirstFunction(num1=2,num2=3) --&gt;
&lt;!-- myResult --&gt;
&lt;!-- sumNum --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Variable scope in functions --&gt;

&lt;!-- Variables defined in the global environment outside the function are available within the function. --&gt;

&lt;!-- ```{r makingfunctionsi,error=FALSE} --&gt;
&lt;!-- my3rdNumber &lt;- 4 --&gt;
&lt;!-- myFirstFunction  &lt;- function(num1,num2){ --&gt;
&lt;!--   sumNum &lt;- num1+num2+my3rdNumber --&gt;
&lt;!--   return(sumNum) --&gt;
&lt;!-- } --&gt;
&lt;!-- myResult &lt;- myFirstFunction(num1=2,num2=3) --&gt;
&lt;!-- myResult --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;
&lt;!-- ##  Variable scope in functions --&gt;

&lt;!-- Changes to variables defined in the global environment from within the function will not be reflected in the global environment. --&gt;

&lt;!-- ```{r makingfunctionsj,error=FALSE} --&gt;
&lt;!-- my3rdNumber &lt;- 4 --&gt;
&lt;!-- myFirstFunction  &lt;- function(num1,num2){ --&gt;
&lt;!--   my3rdNumber &lt;- num1+num2+my3rdNumber --&gt;
&lt;!--   return(my3rdNumber) --&gt;
&lt;!-- } --&gt;
&lt;!-- myResult &lt;- myFirstFunction(num1=2,num2=3) --&gt;
&lt;!-- myResult --&gt;
&lt;!-- my3rdNumber --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ##  Variable scope in functions --&gt;

&lt;!-- We can use a **&lt;&lt;-** to assign to the environment outside the function although we will rarely do this --&gt;

&lt;!-- ```{r makingfunctionsk,error=FALSE} --&gt;
&lt;!-- my3rdNumber &lt;- 4 --&gt;
&lt;!-- myFirstFunction  &lt;- function(num1,num2){ --&gt;
&lt;!--   my3rdNumber &lt;&lt;- num1+num2+my3rdNumber --&gt;
&lt;!--   return(my3rdNumber) --&gt;
&lt;!-- } --&gt;
&lt;!-- myResult &lt;- myFirstFunction(num1=2,num2=3) --&gt;
&lt;!-- myResult --&gt;
&lt;!-- my3rdNumber --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Argument defaults --&gt;

&lt;!-- Functions can have defaults for their arguments which will be used when arguments are not specified. --&gt;

&lt;!-- ```{r makingfunctionsl,error=FALSE} --&gt;
&lt;!-- myFirstFunction  &lt;- function(num1=1,num2=3){ --&gt;
&lt;!--   my3rdNumber &lt;- num1+num2+my3rdNumber --&gt;
&lt;!--   return(my3rdNumber) --&gt;
&lt;!-- } --&gt;
&lt;!-- myFirstFunction() --&gt;
&lt;!-- myFirstFunction(3,4) --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;
&lt;!-- ## Custom function example --&gt;
&lt;!-- User defined functions can be as long and complicated as you want, taking in many variables, printing out messages and utilizing other functions within them. --&gt;

&lt;!-- Lets make z-scores: --&gt;
&lt;!-- ```{r makingfunctions_zscores} --&gt;
&lt;!-- my_zscore  &lt;- function(my_number, my_vector){ --&gt;
&lt;!--   my_mean &lt;- mean(my_vector) --&gt;
&lt;!--   message("Mean is ", my_mean) --&gt;
&lt;!--   diff_from_mean &lt;- my_number-my_mean --&gt;
&lt;!--   stdev &lt;- sd(my_vector) --&gt;
&lt;!--   my_z &lt;- diff_from_mean/stdev --&gt;
&lt;!--   return(my_z) --&gt;
&lt;!-- } --&gt;

&lt;!-- A &lt;- rnorm(20) --&gt;

&lt;!-- my_zscore(my_number=A[1], my_vector=A) --&gt;

&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Debugging functions --&gt;

&lt;!-- In Rstudio, if we want to see what may be happening within our function we can use **debug** function with our function of interest's name. We can stop debugging with the **undebug** function. --&gt;

&lt;!-- ```{r makingfunctionsO,error=FALSE,eval=FALSE} --&gt;
&lt;!-- debug(myFirstFunction) --&gt;
&lt;!-- undebug(myFirstFunction) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Custom functions and apply --&gt;

&lt;!-- These custom functions can also be utilized with apply.  --&gt;

&lt;!-- ```{r, message=F} --&gt;
&lt;!-- sapply(A, my_zscore, my_vector=A) --&gt;

&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;
&lt;!-- ```{r, results='asis',include=TRUE,echo=FALSE} --&gt;
&lt;!-- if(params$isSlides == "yes"){ --&gt;
&lt;!--   cat("class: inverse, center, middle --&gt;

&lt;!-- # Getting Additional Libraries --&gt;

&lt;!-- &lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt;  --&gt;

&lt;!-- --- --&gt;
&lt;!-- "     --&gt;
&lt;!--   ) --&gt;
&lt;!-- }else{ --&gt;
&lt;!--   cat("# Getting Additional Libraries --&gt;

&lt;!-- --- --&gt;
&lt;!-- "     --&gt;
&lt;!--   ) --&gt;

&lt;!-- } --&gt;
&lt;!-- ``` --&gt;


&lt;!-- ## Loading libraries --&gt;

&lt;!-- Libraries can be loaded using the library() function with an argument of the name of the library. --&gt;

&lt;!-- ```{r,eval=F} --&gt;
&lt;!-- library(ggplot2) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- You can see what libraries are available in the Packages panel or by the library() function with no arguments supplied. --&gt;

&lt;!-- ```{r,eval=F} --&gt;
&lt;!-- library() --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Installing libraries --&gt;


&lt;!-- Libraries can be installed through the R studio menu. --&gt;

&lt;!-- **-&gt; Tools -&gt; Install packages ..** --&gt;

&lt;!-- Or by using the install.packages() command. --&gt;

&lt;!-- ```{r,eval=F} --&gt;
&lt;!-- install.packages("Hmisc") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ```{r, results='asis',include=TRUE,echo=FALSE} --&gt;
&lt;!-- if(params$isSlides == "yes"){ --&gt;
&lt;!--   cat("class: inverse, center, middle --&gt;

&lt;!-- # Scripts --&gt;

&lt;!-- &lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt;  --&gt;

&lt;!-- --- --&gt;
&lt;!-- "     --&gt;
&lt;!--   ) --&gt;
&lt;!-- }else{ --&gt;
&lt;!--   cat("# Scripts --&gt;

&lt;!-- --- --&gt;
&lt;!-- "     --&gt;
&lt;!--   ) --&gt;

&lt;!-- } --&gt;
&lt;!-- ``` --&gt;



&lt;!-- ## Saving scripts --&gt;

&lt;!-- Once we have got our functions together and know how we want to analyse our data, we can save our analysis as a **script**. By convention R scripts typically end in **.r** or **.R** --&gt;

&lt;!-- To save a file in RStudio. --&gt;


&lt;!-- **-&gt; File -&gt; Save as** --&gt;


&lt;!-- To open a previous R script --&gt;

&lt;!-- **-&gt;File -&gt; Open File..** --&gt;

&lt;!-- To save all the objects (workspace) with extension **.RData** --&gt;

&lt;!-- **-&gt;Session -&gt; Save workspace as** --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Sourcing scripts --&gt;


&lt;!-- R scripts allow us to save and reuse custom functions we have written.  To run the code from an R script we can use the **source()** function with the name of the R script as the argument.  --&gt;

&lt;!-- The file **dayOfWeek.r** in the "scripts" directory contains a simple R script to tell you what day it is. --&gt;

&lt;!-- ``` --&gt;
&lt;!-- #Contents of dayOfWeek.r --&gt;
&lt;!-- dayOfWeek &lt;- function(){ --&gt;
&lt;!--   return(gsub(" .*","",date()))   --&gt;
&lt;!-- } --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- source("scripts/dayOfWeek.r") --&gt;
&lt;!-- dayOfWeek() --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Rscript --&gt;


&lt;!-- R scripts can be run non-interactively from the command line with the **Rscript** command, usually with the option **--vanilla** to avoid saving or restoring workspaces. All messages/warnings/errors will be output to the console. --&gt;

&lt;!-- ``` --&gt;
&lt;!-- Rscript --vanilla myscript.r --&gt;
&lt;!-- ``` --&gt;

&lt;!-- An alternative to Rscript is **R CMD BATCH**. Here all messages/warnings/errors are directed to a file and the processing time appended. --&gt;

&lt;!-- ``` --&gt;
&lt;!-- R CMD BATCH myscript.r --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Sending arguments to Rscript --&gt;


&lt;!-- To provide arguments to an R script at the command line we must add **commandArgs()** function to parse command line arguments. --&gt;

&lt;!-- ```{r,eval=F} --&gt;
&lt;!-- args &lt;- commandArgs(TRUE) --&gt;
&lt;!-- myFirstArgument &lt;- args[1] --&gt;
&lt;!-- myFirstArgument --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ``` --&gt;
&lt;!-- '10' --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ```{r,eval=F} --&gt;
&lt;!-- as.numeric(myFirstArgument) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ``` --&gt;
&lt;!-- 10 --&gt;
&lt;!-- ``` --&gt;
&lt;!-- Since vectors can only be one type, all command line arguments are strings and must be converted to numeric if needed with **as.numeric()**. --&gt;

---
## Time for an exercise!

Exercise on functions can be found [here](../../exercises/exercises/conditionsAndLoops_exercise.html)

---
## Answers to exercise

Answers can be found here  [here](../../exercises/answers/conditionsAndLoops_answers.html)

---
## What we didn't cover

* [Matrices](https://rockefelleruniversity.github.io/Intro_To_R_1Day/presentations/singlepage/introToR_Session1.html#Matrices)
* [While loops](https://rockefelleruniversity.github.io/Intro_To_R_1Day/presentations/singlepage/introToR_Session2.html#While_loops)
* [Coercing data types](https://rockefelleruniversity.github.io/Intro_To_R_1Day/presentations/singlepage/introToR_Session1.html#Coercing_data_formats)
* [Custom functions](https://rockefelleruniversity.github.io/Intro_To_R_1Day/presentations/singlepage/introToR_Session2.html#Custom_functions)
* [Making scripts](https://rockefelleruniversity.github.io/Intro_To_R_1Day/presentations/singlepage/introToR_Session2.html#Scripts)

---
## Getting help

- From us: Raise an issue on our [GitHub](https://github.com/RockefellerUniversity/RU_introtoR_abridged/issues). This can be suggestions, comments, edits or questions (about content or the slides themselves).
- Google
- Local friendly bioinformaticians and computational biologists.
- [Stackoverflow](http://stackoverflow.com/)
- [R-help](https://stat.ethz.ch/mailman/listinfo/r-help)



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
